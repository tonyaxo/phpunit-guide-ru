# Тестирование базы данных

Многие примеры тестирования на начальном и промежуточном уровнях на любом языке программирования предполагают, 
что несложно протестировать логику вашего приложения с помощью простых тестов. Для приложений, ориентированных 
на базы данных, это совсем не просто. К примеру, если вы используете WordPress, TYPO3 или Symfony с Doctrine или Propel, 
то у вас точно возникнут проблемами с PHPUnit: просто потому, что база данных очень тесно связана с этими библиотеками.

> Note: Удостоверьтесь, что у вас подключено расширение `pdo` и специальное расширение для работы с MySQL `pdo_mysql`
  В противном случаем примеры показанные ниже рабоать не будут.       

Возможно вы сталкивались с похожей ситуацией во время работы над проектом, когда вы хотите применить свои новые знания
в написание PHPUnit тестов и затреваете на таких проблемах как:

1. Тестируемый метод использует большое колличество JOIN-ов что бы вычислить определенные результаты.
2. Ваша бизнес логика выполняет различные опреаторы SELECT, INSERT, DELETE или UPDATE.
3. Вам необходимо настроить тестовые данные в двух и более таблицах, чтобы получить исходные данные для методов 
   которые вы хотите протестировать.

Расширение DbUnit значительно упрощает настройку базы данных для тестирования и позволяет проверять содержимое 
базы данных после выполнения тестов.

## Поддержка СУБД для тестирования

В данный момент DbUnit поддерживает MySQL, PostgreSQL, Oracle и SQLite. Через интеграцию Zend Framework или Doctrine 2 
вы так же можете тестировать другие СУБД такие как IBM DB2 или Microsoft SQL Server.

## Сложности тестирования баз данных

Настройка и обслуживание тестов использующих базы данных достаточно сложное, по этой причине примеры модульного тестирования 
не включают взаимодействие с базой данных. Во время тестирования базы данных вам следуе обратить внимание на следующие
моменты:

- Схема базы и таблиц
- Вставка строк необходимых для тестирования в эти таблицы
- Проверка состояния базы после запуска теста
- Очиста базы после каждого нового теста

Из-за того что многие API-интерфейсы баз данных, такие как PDO, MySQLi или OCI8, громоздки для написания и понимания, 
выполнять эти шаги вручную становится очень проблематично.

Код теста должен быть как можно понятнее и точнее в силу следующих факторов:

- В противном случае вам придется переписывать значительную часть кода теста при не больших изменениях тестируемого кода.
- По прошестивию значительного времени после написания кода теста вам нужно будет легко в нем разбираться. 

Кроме того, вы должны понимать, что база данных представляет собой глобальную входную переменную для вашего кода.

Два и более тестов в вашем наборе тестов могут работать с одной базой, при этом они могут использовать данные повторно.
Падение одного теста может повлиять на результат последующих тестов, тем самым сильно усложнить процесс тестирования.
Поэтому, ранее упомянутый шаг очистки имеет большое занчение при решение проблемы “_база данных - глобальная переменная_”.

DbUnit помогает использовать базу данных в тестах простым и удобным способом.

Однако вам стоит учитывать то что тесты которые используют базу данных очень медленные по сравнению с тестами которые 
работают только с кодом. Продложительность тестов с использованием базы данных на прямую зависит от того на сколько
велико взаимодействие с базой. Однако, если вы будете стараться использовать небольшой объем данных для каждого теста
и тестировать как можно больше кода без использования базы, то вы сможете уложиться в 1 минуту даже для больших 
наборов тестов.

К примеру тетовый набор для Doctrine 2 содержит около 1000 тестов из которых примерно половина использует базу данных, 
и при этом, прохождение тестов укладывается в 15 секунд для MySQL на обычном десктопе.

## Четыре стадии тестирования база данных

В своей книге _Шаблоны тестирования xUnit_ Джерард Месарош перечисляет четыре стадии модульного тестирования:

1. Настройка конфигурации теста (_fixture_)
2. Вызов  тестируемой  системы
3. Проверка результата
4. Очистка тестовой конфигурации

> **Что такое Фикстура (Fixture)?**  
  Фикстура описывает начальное состояние приложениея и базы данных в момент выполнения теста

Тестирование базы данных требует от вас контролировать, по крайней мере, установку и откат для очистки и записи 
необходымиы данных конфигурации в таблицы. Тем неменее, расширение базы данных может отменить четре стадии теста базы 
чтобы восстановить следующий рабочий процесс который исполняется для каждого теста.

#### 1. Очистка базы данных

Во первых, мы не можем точно сказать были ли изменены данные в таблицах при выполнение очередного теста. По этой причине PHPUnit 
выполянет операцию `TRUNCATE` над всеми таблицами которые были указаны для очистки.

#### 2. Настройка начальной конфигурации

Далее PHPUnit проходит по всем указаным строкам в начальной конфигурации и вставляет их в соответствующие таблицы.

#### 3-5. Запуск тестов, проверка результата и очистка

После сброса базы данных и загрузки в начальное состояние, PHPUnit выполянет текущий тест. Эта часть тестового года
не требует понимания работы расширения базы данныв в целом, вы можете продолжать тестировать то что считаете необходимым.

Вы может использовать специальное утверждение `assertDataSetsEqual()` для проверки целей, однако это не обязательно. 
Описание данного метода будет дано ниже в секции “Утверждения базы данных”.

## Конфигурирование тестового класса для базы данных в PHPUnit

Обычно ваши тестовые классы наследуются от `PHPUnit\Framework\TestCase` как показано ниже:

```php
<?php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testCalculate()
    {
        $this->assertEquals(2, 1 + 1);
    }
}
?>
```

Если вы тестируете код который работает с базой данных, то установка становится немного сложнее, в данном случае 
вам нужно расширить класс с помощью `PHPUnit\DbUnit\TestCaseTrait` требующего реализации следуюзих абстрактных методов
`getConnection()` и `getDataSet()`:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this->createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this->createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?>
```

#### Реализация getDataSet()

Метод `getDataSet()` определяет как состояние базы до того как будет выполнен очередной тест. 
Состояние базы данных абстрагируется с помощью концепций DataSet и DataTable, которые представлены интерфейсами 
`PHPUnit_Extensions_Database_DataSet_IDataSet` и `PHPUnit_Extensions_Database_DataSet_IDataTable`.
В следующем разделе будет подробно описано, как работают эти концепции и какие преимущества их использования 
при тестировании базы данных.

Для общего понимания нам необходимо зать только то что метод `getDataSet()` вызывается один раз при вызове `setUp()` 
для извлечения данных начальной конфигурации(fixture) и их вставки в базу данных. В примере мы используем фабричный 
метод `createFlatXMLDataSet($filename)`, который представляет собой данные в XML формате.

#### Что насчет Схемы базы данных (Data Definition Language)?

PHPUnit предполагает, что схема базы данных со всеми ее таблицами, триггерами, последовательностями и представлениями 
создается до запуска теста. Это означает, что вы, как разработчик, должены убедиться что база данных правильно настроена
перед запуском набора тестов.

Есть несколько путей соблюдения указанного условия для базы данных:

1. В случае использования постоянной базы данных (не находящейся в памяти как Sqlite Memory) вы можете единожды настроить
   базу данных с помощью таких инструментов как phpMyAdmin для MySQL и спользовать данную базу повторно для каждого 
   теста.
2. Если вы используете такие библиотеки как Doctrine 2 или Propel, то можете использовать их  API
   для генерации схемы базы данных, достаточно сделать это один раз до запуска тестов.
   Вы можете использовать инструменты загрузки и настройки PHPUnit для выполнения кода настройки пред запуском тестов.
   
#### Совет: используйте собственный Abstract Database TestCase

В предыдущем примере реализации хорошо видно что метод `getConnection()` довольно статичен и может быть повторно 
использован в разных тестовых сценариях использующими базу данных. Чтобы сохранить производительность тестов и снизить 
нагрузуку на базу данных, вы можете произвести рефакторинг кода и написать общий абстактный тетовый класс, который 
по прежнему позволит вам указывать нужную конфигурацию данных для любого тестоваого класса:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class MyApp_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this->conn;
    }
}
?>
```

В примере выше конфигурация базы данных жестко прописана в коде. У PHPUnit есть другая полезная возможность которая 
делает этот пример более продуктивным. При использование [XML конфигурации](organizing-tests.md) вы можете настраивать
соединение с базой данных для каждого теста. Для этого давайте создадим файл `phpunit.xml` в директории `tests/` нашего 
приложения со следующим содержанием:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<phpunit>
    <php>
        <var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" />
        <var name="DB_USER" value="user" />
        <var name="DB_PASSWD" value="passwd" />
        <var name="DB_DBNAME" value="myguestbook" />
    </php>
</phpunit>
```

Теперь мы можем модифицировать пример выше следующим образом:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class Generic_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this->conn;
    }
}
?>
```

Теперь мы можем запускать тестирование базы данных с различной конфигураций используя интерфейс коммандной строки:

```
user@desktop> phpunit --configuration developer-a.xml MyTests/
user@desktop> phpunit --configuration developer-b.xml MyTests/
``` 

Возможность запуска тестов с различной конфигурацией базы очень важна если вы находитесь в рабочем окружении 
(developer machine). Если несколько разработчиков запускаю тесты используя одно соединение с базой данных, вилека 
вероятность падения тестов из-за вхождения в сосояние гонки (race-conditions).

### Введение в DataSets и DataTables

Ключевыми концепциями расширения базы данных для PHPUnit являются DataSets и DataTables. Вы должны понимать данные 
концепции чтобы писать тессыт с использованием базы данных в PHPUnit. DataSets и DataTables представляют собой некий 
абстактный уровень воуркг таблиц базы данных, ее строк и столбцов. API скрывает базовое содержимое базы данных 
в структуре объекта, которая может быть реализовано другими источниками, отличными от базы данных.

Такая абстакция необходима для сравнения текущего содержимого базы данных с ожидаемым. К пример ожидания могут быть 
представлены как XML, YAML, CSV-файлы или PHP-массивы. Интерфейсы DataSet и DataTable позволяют сравнивать эти 
концептуально разные источники данных, используя подход семантической эмуляции реляционной базуы данных.

Таким образом процесс взаимодействия с базой данных в ваших тестах сводится к трем простым шагам:

- Определение одной и более таблиц в базе с помощью именования (текущий набор данных(dataset))
- Определение ожидаемого набора данных(dataset)
- Проверить что оба набора даных эквивалентны

DataSets и DataTables расштрения базы данных PHPUnit используются не только для проверки утверждений. Как показано в 
примере выше, они так же описывают начальные данный в базе. Вы вынуждены определеять начальное состояние базы используя 
Database TestCase, которое в дальнейшем используется для:

- Удаления всех строк из таблиц указанных в наборе данных (dataset)
- Записи всех строк в таблицы базы данных

### Варианты рализации

 Существует три различных типа наборов данных/таблиц:
 
 - Наборы основанные на файлах
 - Наборы основанные на запросах
 - Набор созданный с помощью фильтров и композиций
 
#### Набор данных в виде Flat XML (простой XML)

Самый общий набор данных называемый Flat XML. Это очень упрощенный формат XML, в котором тег внутри корневого узла 
`<dataset>` представляет собой ровно одну строку в базе данных. Название тега обозначает имя таблицы для вставки строки,
a атрибуты соответствуют столбцам таблицы. К примеру, набор данных для гостевой книги может выглядеть так:

```xml
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Привет дружище!" user="Ваня" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="Обощаю это!" user="Мария" created="2010-04-26 12:14:20" />
</dataset>
```

Очевидно, что такая форма проста для записи. В данном случае `<guestbook>` является именем таблицы в которую вставляются 
двсе строки с четырьмя колонками `id`, `content`, `user` и `created` с соответстующими значениями.

Однако такая простота дорого стоит.

Из предыдущего примера не очевидно каким образом можно задать пустую таблицу. Для этого вы можете указать пустой тег без
атрибутов. Тогда файл в формате Flat XML для пустой гостевой книги будет выглядеть так: 

```xml
<?xml version="1.0" ?>
<dataset>
    <guestbook />
</dataset>
```

Отдельно стоит отметить неудобство связанное со значением NULL. В большинстве СУБД значение NULL не тождественно равно 
пустой строке, что трудно описать в формате Flat XML. Вы можете определить NULL значение опустив определение атрибута из
спецификации строки. Если мы разрешаем анонимным пользователям оставлять записи в гостевой книге, тогда можно опредеить
набор данных следующим образом:

```xml
<dataset>
    <guestbook id="1" content="Привет дружище!" user="Ваня" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="Обощаю это!" created="2010-04-26 12:14:20" />
</dataset>
```

В таком случае вторая запись оставлена анонимным пользователем. Однако это приводит к проблемам определения столбцов 
таблицы. При сравнение наборов данных, каждый из них должен указать какие столбцы содержит таблица. Если атрибут
является NULL для всех строк в таблице, а значит не указан в наборе, то как определить какие столбцы должны содержать 
таблица?

В данном случае основным предположением для Flat XML является то, что в первой строке набора определяются все столбцы
таблицы. Для примера выше это означает что `id`, `content`, `user` и `created` являются столбцами в таблице guestbook.
В случае второй строки где атрибут `user` не определен значению данного столбща присваевается NULL.

Если удалить первую строку из из набора guestbook, то столбцами данной таблицы будут считаться только `id`, `content`
и `created` т.к `user` не определена.

Чтобы эфективно использовать наборы данных в Flat XML, когда необходимо использовать NULL значения, нобходимо чтобы 
первая строка в наборе не содержала значений NULL и пропущенные атрибуты содержались только в последующих строках.

С другой стороны, если в формате Flat XML указать только подмножество столбцов таблицы, то все пропущенные столбцы будут 
инициализированны значениями по умолчанию. Это приводит к ошибкам в случае если один из пропущенных столбщов определен 
как _NOT NULL DEFAULT NULL_.

В качестве заключения предлагается использовать формат Flat XML только когда нет необходимости в использование значений
NULL.

Вы может создать набор данных из формата flat xml внутри класса Database TestCase вызвав метод 
`createFlatXmlDataSet($filename)`:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?>
```

#### Набор данных XML

Данный формат набора данных представлят собой другой, боле структурированый XML, он немного сложнее в описание, 
но позволяет решить проблему определения NULL значний. Внутри узла `<dataset>` вы может определитять теги 
`<table>`, `<column>`, `<row>`, `<value>` и `<null />`. Набор данных эквивальтный предыдущему в примере с гостевой 
книгой будет выглядеть следующим образом:

```xml
<?xml version="1.0" ?>
<dataset>
    <table name="guestbook">
        <column>id</column>
        <column>content</column>
        <column>user</column>
        <column>created</column>
        <row>
            <value>1</value>
            <value>Hello buddy!</value>
            <value>joe</value>
            <value>2010-04-24 17:15:23</value>
        </row>
        <row>
            <value>2</value>
            <value>I like it!</value>
            <null />
            <value>2010-04-26 12:14:20</value>
        </row>
    </table>
</dataset>
```

Любая определенная `<table>` содержит имя и требует определения всех столбцов с их именами. Данный элемент может
содержать ноль и более вложенных узлов `<row>`. Если ни одного узла `<row>` не определно, то таблица считается пустой.
Теги `<value>` и `<null />` должны быть указаны в соответсвие с порядком указания элементов `<column>`. Очевидно что
тег `<null />` представляет собой NULL значение. 

Вы может создать набор данных из формата XML, вызвав метод `createXmlDataSet($filename)` внутри класса Database 
TestCase:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this->createXMLDataSet('myXmlFixture.xml');
    }
}
?>
```

#### Набор данных в формате MySQL XML

Это новый XML формат определнный в [MySQL database server](http://www.mysql.com/). Поддержка данного формата добавлена
начиная с PHPUnit 3.5. Файл такого формата может быть сгенерирован с помощью утилиты 
[`mysqldump`](https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html). В отличие от CSV формата, который так же
поддеживает `mysqldump`, в одном фале XML может содержать данные несколько таблиц. Вы можете создать файл в формате 
MySQL XML с помощьюследующей команды:

```
mysqldump --xml -t -u [username] --password=[password] [database] > /path/to/file.xml
```

Полученный файл может быть использован внутри класса Database TestCase вызовом метода `createMySQLXMLDataSet($filename)`:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this->createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?>
```

#### Формат YAML

В качестве альтернативы вы можете использовать набор данных в YAML формате:

```yaml
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
```

Этот подход удобен и прост, а главное он решает проблему NULL значений, которая является основной в формате Flat XML.
В формате YAML если столбцу не присваивается значение то он считается равным NULL. Пустая строка определяется следующим
образом `column1: ""`.

Для YAML формата на данный момент в Database TestCase не сущес фабричного метода, однако вы можете создать его вручную:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\YamlDataSet;

class YamlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new YamlDataSet(dirname(__FILE__)."/_files/guestbook.yml");
    }
}
?>
```

#### Формат CSV

Еще один основанный на файлах набор данных в формате CSV. Каждый файл в формате CSV описывает одну таблицу в базе.
Для нашей гостевой книги мы можем создать файл `guestbook-table.csv` со следующим содержимым:

```text
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
```

С одной стороны это очень удобно редактировать средствами Excel или OpenOffice, однако вы не можете вставлять NULL 
значения в формате CSV. Пустой столбец приведет к вставке в базу данный значения по умолчанию вместо NULL.

Для создания набора данных из CSV файла используя следующий пример:

```php
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\CsvDataSet;

class CsvGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        $dataSet = new CsvDataSet();
        $dataSet->addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?>
```

#### Набор данных из PHP массива