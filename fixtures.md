# Фикстуры

Одна из самых трудозатратных частей написания тестов - это написание кода приводящего среду в некое известное состояние и возвращение в исходное после завершения теста. Это изветное состояние называется _фикстурой_ теста.

В примере 2.1 фикстурой является обычный массив хранящий переменную `$stack`. В большинстве случаев фикстура будет более сложной чем простой массив, и количество кода, необходимое для ее настройки, будет соответственно расти.
Фактическое содержание теста теряется в суете настройки фикстуры. 
Проблема становится еще хуже когда вы пишете несколько тестов с похожими фикстурами. Без некоторой помощи тестового фреймворка мы получим дублирование кода который настраивает фикстуру для каждого теста.

PHPUnit поддерживает шаринг кода настройки. Перед запуском теста вызывается метод `setUp()`. `setUp()` - это то где вы создаете объекты на которых вы будете производиться тестирование.
После того как тестовый метод завершает работу, не зависимо от результата прохождения теста, запускается метод `tearDown()`. `tearDown()` - это то место где вы очищаете обекты на каторых проводите тесты.

В примере 2.2 мы использовали отношение производитель-потребитель чтобы расшарить их фикстуру. Такой способ не всегда желателен или деже возможен. 
Пример 4.1 показывает как можно написать тесты для `StackTest` с использованием кода создания фикстуры. 
Сначала мы определяем переменную `$stack` которую будем использовать вместо локальной переменной в тестовых методах.
Далее помещем код создания фикстуры в виде массива в метод `setUp()`.
И наконец, удаляем лишний код из тестовых методов заменив его на код с использованием новой переменной, `$this->stack` вместо локальной переменной `$stack`, в вызове `assertEquals()`.

**Пример 4.1: Использование `setUp()` для создания викстуры стека**
```php
<?php
use PHPUnit\Framework\TestCase;

class StackTest extends TestCase
{
    protected $stack;

    protected function setUp()
    {
        $this->stack = [];
    }

    public function testEmpty()
    {
        $this->assertTrue(empty($this->stack));
    }

    public function testPush()
    {
        array_push($this->stack, 'foo');
        $this->assertEquals('foo', $this->stack[count($this->stack)-1]);
        $this->assertFalse(empty($this->stack));
    }

    public function testPop()
    {
        array_push($this->stack, 'foo');
        $this->assertEquals('foo', array_pop($this->stack));
        $this->assertTrue(empty($this->stack));
    }
}
?>
```

Методы `setUp()` и `tearDown()` запускаются один раз для каждого теста в классе. 
Кроме этого, методы `setUpBeforeClass()` и `tearDownAfterClass()` запускаются до первого теста и после последнего теста соответственно.

Пример ниже демонстрирует все шаблонные методы тестового кейса.

**Пример 4.2: Все шаблонные методы тестового кейса**
```php
<?php
use PHPUnit\Framework\TestCase;

class TemplateMethodsTest extends TestCase
{
    public static function setUpBeforeClass()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function setUp()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function assertPreConditions()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    public function testOne()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
        $this->assertTrue(true);
    }

    public function testTwo()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
        $this->assertTrue(false);
    }

    protected function assertPostConditions()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function tearDown()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    public static function tearDownAfterClass()
    {
        fwrite(STDOUT, __METHOD__ . "\n");
    }

    protected function onNotSuccessfulTest(Exception $e)
    {
        fwrite(STDOUT, __METHOD__ . "\n");
        throw $e;
    }
}
?>
```
```
phpunit TemplateMethodsTest
PHPUnit 6.1.0 by Sebastian Bergmann and contributors.

TemplateMethodsTest::setUpBeforeClass
TemplateMethodsTest::setUp
TemplateMethodsTest::assertPreConditions
TemplateMethodsTest::testOne
TemplateMethodsTest::assertPostConditions
TemplateMethodsTest::tearDown
.TemplateMethodsTest::setUp
TemplateMethodsTest::assertPreConditions
TemplateMethodsTest::testTwo
TemplateMethodsTest::tearDown
TemplateMethodsTest::onNotSuccessfulTest
FTemplateMethodsTest::tearDownAfterClass


Time: 0 seconds, Memory: 5.25Mb

There was 1 failure:

1) TemplateMethodsTest::testTwo
Failed asserting that <boolean:false> is true.
/home/sb/TemplateMethodsTest.php:30

FAILURES!
Tests: 2, Assertions: 2, Failures: 1.
```

## setUp() чаще чем tearDown()

`setUp()` и `tearDown()` отлично сбалансированы в теории но не на практике. Чаще всего, на практике, вам нужно будет реализовывать метод `tearDown()` только если вы внешние ресурсы , такие как  файлы или сокеты, в реализации `setUp()`.
Вы можете вообще не рализовывать `tearDown()` если в методе `setUp` создаются только простые объекты. 
Однако, если высоздаете большое количество объектов в `setUp()`, вам может потребоваться освободить ресурсы переменных указывающие на эти объекты с помощью `unset()` в
реализации `tearDown()` чтобы они были обработаны сборщиком мусора. Сбор мусора объектов тестового кейса не предсказуем.

## Вариации

Что делать если у вас есть два теста с приблизительно одинаковыми настройками? Есть два пути:

* Если код реалихации `setUp()` отличается не сильно, перенемите отличающийся фрагмент из `setUp()` в тестовый метод.
* Если код реализации отличается координально, значит нужно создавать новый тестовый кейс.

## Шаринг фикстур

Есть несколько веских причин для шаринга фикстур между тестами, но в большинстве случаев необходимость совместного использования фикстур связана с неразрешенной проблемой проектирования.
Шорошим примером при котором шаринга фикстур между некоторыми тестами имеет смысл является соединение с базой данных: вы используете одно соединение вместо того чтобы создавать его в каждом тесте. 
Это позволяет тестам проходить быстрее.

В примере 4.3 показано как использовать методы `setUpBeforeClass()` и `tearDownAfterClass()` для создания соединения с базой в начале тестового кейса и закрытия соединения после прохождения всех тестов соответственно.

**Пример 4.3: Шаринг фикстур между тестами**
```php
<?php
use PHPUnit\Framework\TestCase;

class DatabaseTest extends TestCase
{
    protected static $dbh;

    public static function setUpBeforeClass()
    {
        self::$dbh = new PDO('sqlite::memory:');
    }

    public static function tearDownAfterClass()
    {
        self::$dbh = null;
    }
}
?>
```

Нельзя сказать, что совместное использование фикстур между тестами снижает их значимость. Основная проблема такого подхода это жесткая связанность объектов.
Можно добиться результатов сначала решив проблему жесткой связанности с последующем написанием тестов изпользуя заглушки (см. Главу 9) вместо создания зависимостей между тестами во время выполнения и игнорирования возможность улучшения дизайна.

## Глобальное пространство

[Очень сложно тестировать код использующий патерн синглтон](https://testing.googleblog.com/2008/05/tott-using-dependancy-injection-to.html). Э
то так же верно для кода использующего глобальные переменные.
Обычно, когда тестируемый код сильно связан с глобальноцй переменно вым сложно контролировать его создание. 
Так же следует учитывать что изменение одним тестом глобальной переменной может обружить остальные.

В PHP глобальные переменные работают следующим образом:

* Глобальная переменна `$foo = 'bar';` храниться как `$GLOBALS['foo'] = 'bar';`.
* Переменная `$GLOBALS` также называется сепер-глобальной.
* Супер-глобальные переменные создаются в начале рабты скрипта и всегда доступны во всех областях видимости.
* В области видимости функци или метода вы можете получить доступ к глобальной переменной `$foo` либо напрямую обращаясь к `$GLOBALS['foo']`
  или используя `global $foo;` чтобы создать локальную переменную ссылающуюся на глобальную.
  
Помимо глобальных переменных, статические атрибуты класса также доступны в глобальном пространстве.

По умолчанию PHPUnit запускает тесты таким образом, что изменения глобальных и суперглобальных переменных (`$GLOBALS`, `$_ENV`, `$_POST`, `$_GET`, `$_COOKIE`, `$_SERVER`, `$_FILES`, `$_REQUEST`)  не влияют на другие тесты.
При необходимости уровень изоляции может быть распростанен на статические атрибуты классов.

> Note: Операции сохранения и востановления глобальных переменных и статичных атрибутов класса используют функции `serialize()` и `unserialize()`.
  Объекты некоторых классов (как `PDO`) не могут быть сериализованы из-за этого в случае сохранения таких объектов в массиве `$GLOBALS` операции сохранения не будут выполнены.
  
Для управления операциями сохранения глобальных переменных может быть использована аннотация `@backupGlobals`, информацию о которой можно найти в риложении.
Так же вы можете указать список глобальных переменных которые будут исключены из операций сохранения и восстановления, следующим образом

```php
class MyTest extends TestCase
{
    protected $backupGlobalsBlacklist = ['globalVariable'];

    // ...
}
```

> Note: Установка свойства `$backupGlobalsBlacklist` в таких методах как `setUp()` не будет иметь эфекта.

Аннотация `@backupStaticAttributes` используется для сохранения и восстановления всех статических переменных класса для всех 
объявсленных классов для каждого теста.

> Note: Операция `@backupStaticAttributes` выполняется перед тестовым методом, но только если она включена. 
  Если значение статической переменной было изменено ранее выполненным тестом, для которого не было активно `@backupStaticAttributes`, тогда именно это значение будет скопировано и восстановлен а не первоначально объявленное значение по умолчанию. 
  Php не записывает первоначально объявленное значение по умолчанию для любой статической переменной.
> То же самое относится к статическим свойствам классов, которые были объявлены в рамках теста. Они не могут быть выставлены к исходному значению по умолчанию после прохождения теста
  так как это значение неизвестно. Любые изменения значений переходят в следующие тесты.
> Для модульных тестов рекомендуется явно сбросить значения статических свойств в тесте в коде `setUp()` (также и в `tearDown()`, чтобы не повлиять на последующие выполненные тесты).

Вы можете указать список статических атрибутов которые будут исключены из операций сохранения и восстановления следующим образом:

```php
class MyTest extends TestCase
{
    protected $backupStaticAttributesBlacklist = [
        'className' => ['attributeName']
    ];

    // ...
}
```  

> Note: Установка свойства `$backupStaticAttributesBlacklist` в таких методах как `setUp()` не будет иметь эфекта.